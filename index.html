<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
		<style type="text/css">
			a {
				color:				#5070B0;
				text-decoration:	none;
			}

			a:hover {
				color:				#6080C0;
				text-decoration:	underline;
			}

			body {
				padding:	0px;
				margin:		32px 64px;
				font:		normal normal normal 0.9em 'Trebuchet MS', Helvetica, sans-serif;
			}

			div.code {
				position:		relative;
				padding:		10px 6px 1px 6px;
				margin:			12px 8px;
				background:		#D0E0F0;
				border-top:		1px solid #80A0B0;
				border-right:	1px solid #A0C0D0;
				border-bottom:	1px solid #A0C0D0;
				border-left:	1px solid #80A0B0;
				border-radius:	6px;
			}

			div.code code {
				font:			normal normal normal 1.0em monospace;
				white-space:	pre;
			}

			div.code code strong {
				background:		#D0C0B0;
				font-weight:	bold;
			}

			div.code blockquote {
				position:	relative;
				top:		-18px;
				height: 	0px;
				padding:	0px;
				margin:		0px;
			}

			div.code blockquote span {
				padding:		0px 4px 0px 5px;
				background:		#B0C6E0;
				border-top:		1px solid #C0D0F0;
				border-right:	1px solid #A0B0C0;
				border-bottom:	1px solid #A0B0C0;
				border-left:	1px solid #C0D0F0;
				border-radius:	6px;
				font-size:		0.7em;
				font-weight:	bold;
			}

			div.section {
				margin:		8px 0px 48px 0px;
			}

			div.section div.section {
				margin:		8px 0px 32px 0px;
			}

			div.section div.section div.section {
				margin:		8px 0px 24px 0px;
			}

			div.section p {
				margin:	12px 8px;
			}

			div.section ul {
				padding:	4px 32px;
				margin:		8px 0px;
				list-style:	circle;
			}

			div.section ul ul {
				padding:	0px 32px;
				margin:		0px;
			}

			div.section p code,
			div.section ul code {
				background:	#E0E0E0;
				font:		normal normal normal 1.0em monospace;
			}

			div.toc {
				position:	absolute;
				left:		4px;
				top:		4px;
			}

			div.toc span.handle {
				cursor:			pointer;
				padding:		1px 8px 1px 9px;
				background:		#B0C6E0;
				border-top:		1px solid #C0D0F0;
				border-right:	1px solid #A0B0C0;
				border-bottom:	1px solid #A0B0C0;
				border-left:	1px solid #C0D0F0;
				border-radius:	6px;
				font-size:		0.7em;
				font-weight:	bold;
			}

			div.toc ul {
				display:		none;
				padding:		1px 6px;
				margin:			2px;
				background:		#D0E0F0;
				border-top:		1px solid #80A0B0;
				border-right:	1px solid #A0C0D0;
				border-bottom:	1px solid #A0C0D0;
				border-left:	1px solid #80A0B0;
				border-radius:	4px;
				font-size:		0.9em;
				line-height:	16px;
				list-style:		none;
			}

			div.toc:hover ul {
				display:		block;
			}

			div.toc ul ul {
				display:		block;
				padding:		0px 6px;
				margin:			0px 2px;
				background:		transparent;
				border-top:		0px;
				border-right:	0px;
				border-bottom:	0px;
				border-left:	0px;
			}

			h1 {
				padding:	0px;
				margin:		24px 8px;
				text-align:	center;				
				font-size:	2.0em;
				color:		#4060A0;
			}

			h2 {
				padding:	0px;
				margin:		8px 16px;
				font-size:	1.4em;
				color:		#5070B0;
			}

			h3 {
				padding:	0px;
				margin:		8px 24px;
				font-size:	1.0em;
				color:		#6080C0;
			}
		</style>
		<title>Cottle Documentation</title>
	</head>
	<body>
		<h1>Cottle Documentation</h1>
		<div class="section" id="toc-from">
			<h2>Cottle overview</h2>
			<div class="section">
				<h3>What is Cottle, and what does it looks like?</h3>
				<div class="section">
					<p>Cottle, short for "<u>C</u>ompact <u>O</u>bject to
					<u>T</u>ext <u>T</u>ransform <u>L</u>anguag<u>e</u>" is a
					lightweight template engine in .NET 3.5 allowing you to
					transform structured data into any text-based format
					output like plain text, HTML or XML. It uses a simple yet
					highly extensible template language, thus enabling clean
					separation of document content (data structure) and
					document presentation.</p>
					<p>A simple Cottle template printing an HTML document
					showing how many messages are in your mailbox could look
					like this:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>&lt;html&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello, {name}!&lt;/h1&gt;
        &lt;p&gt;
            {if gt(len(messages),0):
                You have {len(messages)} new message{if gt(len(messages),1):s} in your mailbox!
            |else:
                You have no new message.
            }
        &lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</code>
					</div>
					<p>As you can guess by looking at this code, a Cottle
					template contains both "raw" text printed directly and
					special tags used to control how text output is generated.
					Cottle supports most common template engine features, such
					as:</p>
					<ul>
						<li>Text substitutions through variables,</li>
						<li>Builtin and used-defined functions,</li>
						<li>Variables & functions declaration and
						assignments,</li>
						<li>Conditional statements (if),</li>
						<li>Loops (for, while).</li>
					</ul>
					<p>Source code is available, and contributions will be
					highly welcomed!</p>
				</div>

				<h3>Download the library</h3>
				<div class="section">
					<p>You can download the last version of Cottle on Github,
					by following this link:
					<a href="https://github.com/r3c/Cottle">https://github.com/r3c/Cottle</a>.</p>
				</div>

				<h3>About this documentation</h3>
				<div class="section">
					<p>The intent of this document is to explain how Cottle
					works, how to write templates and how to use them in your
					code. Most features will be introduced with a code sample
					to ease readability.</p>
					<p>Using Cottle in your code requires two things:</p>
					<ul>
						<li>An input template written in Cottle format, used to
						control how your data must be rendered. This template
						can be streamed from any source compatible with
						<code>System.IO.TextReader</code> class (text file,
						memory buffer, network socket...) as shown in the
						example below.</li>
						<li>An executable code that parses the template into a
						<code>Cottle.IDocument</code> instance, then renders it
						into an output string or writer.</li>
					</ul>
					<p>Here is a simple use case:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Text contents of the template file 'test.cottle'.</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>private void   SomeFunction()
{
    IDocument  document;
    IScope     scope;

    using (StreamReader template = new StreamReader(new FileStream("test.cottle", FileMode.Open), Encoding.UTF8))
    {
        document = new SimpleDocument(template); // may throw a ConfigException or DocumentException on error
    }

    scope = new DefaultScope(); // create a new scope to store values

    /* TODO: assign some values to scope */

    document.Render(scope, Console.Out); // may throw a RenderException on error
}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Text contents of the template file 'test.cottle'.</code>
					</div>
					<p>Since the sample C# codes used in example is quite
					redundant, only specific parts for each one will appear in
					following examples. They should be inserted where the
					"TODO" comment is located. Common parts of the code won't
					be shown anymore.
					</p>
				</div>
			</div>
			
			<h2>Template fundamentals</h2>
			<div class="section">
				<h3>Simple raw text output</h3>
				<div class="section">
					<p>Everything you type into a Cottle template will be
					printed "as is" in the result document, except for some
					special characters. That means raw text will appear exactly
					as you entered it in your template, as shown in this
					example:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Hello, world!</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Hello, world!</code>
					</div>
				</div>

				<h3>Using commands in templates</h3>
				<div class="section">
					<p>A Cottle template can contain commands which will
					trigger special behaviors such as printing value of
					variables, using conditional statements, etc.</p>
					<p>To write a command, use the "{" (left brace) character
					followed by the name of the command you want to use and its
					parameters, then a "}" (right brace) character to end it.
					Here is an example using the <code>echo</code> command
					which outputs the value of a variable or constant:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>The answer is: {echo 42}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>The answer is: 42</code>
					</div>
					<p>Of course, this template sample has no actual use as it
					results in a constant string, but we'll see more realistic
					examples in following sections.</p>
					<p>You'll see later that some commands, such as the
					<code>if</code> comamnd, also require a body which must
					appear between a ":" (colon) character and the "}" at the
					end of the command:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{if condition:something}</code>
					</div>
					<p>Command bodies are always raw text, not code, so in this
					example "something" will be printed if the <code>if</code>
					command is satisfied. You can of course use commands from
					within another command body:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{if condition:{echo result}}</code>
					</div>
				</div>

				<h3>Sending variables to a template</h3>
				<div class="section">
					<p>To send variables to parsed document so they can be used
					while rendering, you must use a <code>Cottle.IScope</code>
					instance that will hold them. This class behaves quite like
					a <code>Dictionary&lt;Cottle.Value,Cottle.Value&gt;</code>,
					where <code>Cottle.Value</code> is an internal Cottle type.
					Key and value pairs within this dictionary are used as
					variable names and associated values. Implicit constructors
					from some native .NET types to <code>Value</code> type are
					provided so most of the time you won't have to explicitly
					build <code>Value</code> objects yourself, but you can
					check in <code>Cottle.Values</code> namespace for available
					types.</p>

					<p>Once assigned, variables can be used in the template,
					for example by using the <code>echo</code> command that
					can output the value of any variable:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Hello {echo name}, you have no new message.</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["name"] = "John"; // implicit conversion to Value, new StringValue("John") is valid too</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Hello John, you have no new message.</code>
					</div>
					<p>As <code>echo</code> is the most commonly used command a
					shorter form is available and you can omit the "echo"
					keyword if the name of the variable you want to print
					doesn't conflict with another command:
					<code>{echo name}</code> is equivalent to
					<code>{name}</code> in this example. This form will be used
					in all following samples.</p>
				</div>

				<h3>Escaping special characters</h3>
				<div class="section">
					<p>There are four special characters that won't be printed
					unless you escape them, since they're used by template
					parser to trigger special behaviours. Special characters
					are:</p>
					<ul>
						<li>{ and }  (opening and closing braces),</li>
						<li>| (pipe),</li>
						<li>\ (backslash).</li>
					</ul>
					<p>If you need to print one of these in your template, you
					must preceed them with a backslash character:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Special characters \{, \}, \| and \\ must be escaped.</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Special characters {, }, | and \ must be escaped.</code>
					</div>
					<p>Special characters can be changed as you'll see in
					section
					"<a href="#block_delimiters_customization">Block delimiters customization</a>".</p>
				</div>

				<h3>Using map values</h3>
				<div class="section">
					<p>Map values are associative tables that contain multiple
					values stored as key/value pairs. Keys and values can be
					either scalar values or other nested map values. Values
					within a map value can be accessed directly by their key,
					using either dotted or subscript notation:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>You can use either {mymap.f1} or {mymap["f2"]} notations for map values.</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["mymap"] = new Dictionary&lt;Value,Value&gt; // implicit conversion to MapValue
{
    {"f1", "dotted"},
    {"f2", "subscript"}
};</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>You can use either dotted or subscript notations for map values.</code>
					</div>
					<p>Please node the quotes used in subscript notation.
					Trying to access value of <code>{mymap[f2]}</code> will
					result in a very different behavior, since it will search
					for the value whose key is the value of <code>f2</code>
					(which hasn't be defined), leading to an undefined (void)
					result.</p>
					<p>It is valid to have a map in which two or more keys
					are equal, but you will only be able to access the last
					one when using direct access. However, iteration through
					the map's elements, as we'll see later, will show you
					its entire content.</p>
				</div>

				<h3>Literals and variables</h3>
				<div class="section">
					<p>All commands in Cottle, like <code>echo</code>, must be
					called with values as arguments. These arguments can be
					names of variables you set through .NET code before
					rendering the template, constant literals, or any
					expression returning a value (this last case will be
					explained in details later in this document).</p>
					<p>Here is how to use literal values in your templates:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{17.42}
{"Constant string value"}
{'String with single quotes'}
{["key1": "value1", "key2": "value2", 43: "value for key 43"]}
{["constant", "map", "with", "auto-generated", "numeric", "keys"]}
{[1: ["map", "with"], "mixed": "values"]}</code>
					</div>
					<p>As you can see in this example, literals can be:</p>
					<ul>
						<li>Integer or decimal numeric constants,</li>
						<li>Character strings delimited by either single or
						double quotes,</li>
						<li>Maps with either key/value pairs or values
						only (numeric keys starting at index 0 are generated in
						this case)</li>
					</ul>
				</div>

				<h3 id="calling_functions">Calling functions</h3>
				<div class="section">
					<p>Functions in Cottle are special values that can be
					called just like functions in any programming language,
					using this syntax:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>You have {len(messages)} new message(s) in your inbox.</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>IScope  scope;

scope = new DefaultScope(); // see below for details about this line

scope["messages"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "message #0"},
    {1, "message #1"},
    {2, "message #2"}
};</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>You have 3 new message(s) in your inbox.</code>
					</div>
					<p>Please note the use of a <code>DefaultScope</code>
					object in this sample. This special sub-class of the
					<code>IScope</code> interface comes with all Cottle
					default functions assigned automatically. You could also
					use another object if you don't need or don't want these
					functions. For example, the <code>SimpleScope</code> class
					as no default value assigned.</p>
					<p>To get a description of each of the functions assigned
					when using a <code>DefaultScope</code> object, see
					paragraph
					"<a href="#common_functions">Common functions</a>". For all
					following samples, we'll assume that common functions are
					assigned before template is rendered.</p>
				</div>

				<h3>Commenting your templates</h3>
				<div class="section">
					<p>You can use the <code>_</code> (underscore) command to
					add comments to your template. This command can be followed
					by any literal text and won't print any result when
					template is rendered.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{_ This is a comment that will be ignored when rendering the template}
Hello, World!</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Hello, World!</code>
					</div>
				</div>
			</div>

			<h2>Flow control</h2>
			<div class="section">
				<h3 id="conditional_statements">Conditional statements</h3>
				<div class="section">
					<p>You can write conditional statements by using the
					<code>if</code> command which evaluates a value (which can
					be a variable or the result of a function call) as a
					boolean to check if its body should be printed or not.
					A condition is satisfied if the value as a boolean is true:
					any void value, empty string, zero number or empty map will
					be converted to a boolean "false" value whereas any other
					value will be converted to "true".</p>
					<p>The <code>if</code> command also supports optional
					<code>elif</code> (else if) and <code>else</code> blocks
					that behave like in any programming language.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{if 1:
    A condition on a numeric value is true if the value is non-zero.
}

{if test: Variable "test" is true! |else: Variable "test" is false! }

{if gt(len(items), 2):
    There are more than two items in map ({len(items)}, actually).
}

{if lt(x, 0):
    X is negative.
|elif gt(x, 0):
    X is positive.
|else:
    X equals zero.
}</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["items"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "item #0"},
    {1, "item #1"},
    {2, "item #2"}
};

scope["test"] = 42;
scope["x"] = -3;</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>A condition on a numeric value is true if the value is non-zero.

Variable "test" is true!

There are more than two items in map (3, actually).

X is negative.</code>
					</div>
				</div>

				<h3>Maps enumeration</h3>
				<div class="section">
					<p>Pairs contained within a map value can be enumerated
					with the <code>for</code> command, that will print its body
					for each key/value pair it found. An alternative syntax can
					be used if you only want to iterate on values and don't
					care about keys. The <code>for</code> command also supports
					an optional <code>empty</code> block printed when the map
					you tried to enumerate doesn't contain any key/value
					pair.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{for index, text in messages:
    Message #{add(index, 1)}: {text}
|empty:
    No messages to display.
}

Tags: {for tag in tags:{tag} }</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["messages"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "Hi, this is a sample message!"},
    {1, "Hi, me again!"},
    {2, "Hi, guess what?"}
};

scope["tags"] = new Value[]
{
    "action",
    "horror",
    "fantastic"
};</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Message #1: Hi, this is a sample message!
Message #2: Hi, me again!
Message #3: Hi, guess what?

Tags: action horror fantastic</code>
					</div>
				</div>

				<h3 id="variables_assignment">Variables assignment</h3>
				<div class="section">
					<p>You can assign variables while template is being
					rendered by using the <code>set</code> command. Variable
					assignment allows you improve performance by storing
					evaluation results (such as function calls) that are going
					to be used several times, or code complex template
					mechanism by combining the <code>if</code>,
					<code>for</code> and <code>set</code> commands.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set nb_msgs to len(messages)}

{if gt(nb_msgs,0):
    You have {nb_msgs} new message{if gt(nb_msgs, 1):s} in your mailbox!
|else:
    You have no new message.
}

{set nb_long to 0}

{for message in messages:
    {if gt(len(message), 20):
        {set nb_long to add(nb_long, 1)}
    }
}

{nb_long} message{if gt(nb_long, 1):s is|else: are} more than 20 characters long.</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["messages"] = new Dictionary&lt;Value,Value&gt;
{
    {0, "Hi, this is a sample message!"},
    {1, "Hi, me again!"},
    {2, "Hi, guess what?"}
};</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>You have 3 new messages in your mailbox!

1 message is more than 20 characters long.</code>
					</div>
					<p>You can assume that all variables are set in a global
					common scope. More advanced use of variable assignments
					will be explained later in this document.</p>
					<p>Variables in Cottle are immutable, so it's not possible
					to assign some value to a map subscript. If you want to
					append, replace or erase a value in a map, you'll have
					to build a new one and inject, filter out or replace
					desired value. Common functions
					"<a href="#function_cat">cat</a>",
					"<a href="#function_slice">slice</a>",
					"<a href="#function_union">union</a>",
					"<a href="#function_except">except</a>" can be used to
					easily achieve such operations:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set my_array to [4, 8, 50, 90, 23, 42]}
{set my_array to cat(slice(my_array, 0, 2), slice(my_array, 4))}
{set my_array to cat(slice(my_array, 0, 2), [15, 16], slice(my_array, 2))}
{dump my_array}

{set my_hash to ["delete_me": "TODO: delete this value", "let_me": "I shouldn't be touched"]}
{set my_hash to union(my_hash, ["append_me": "I'm here!"])}
{set my_hash to except(my_hash, ["delete_me": 0])}
{dump my_hash}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>[0: 4, 1: 8, 0: 15, 1: 16, 4: 23, 5: 42]
["let_me": "I shouldn't be touched", "append_me": "I'm here!"]</code>
					</div>					
				</div>

				<h3>Conditional loops</h3>
				<div class="section">
					<p>The <code>while</code> command is the equivalent of the
					"while" keyword in most programming languages. Be sure to
					check for a condition that will become false after a finite
					number of iterations, or rendering of your template will
					never complete. When possible, prefer the use of the
					<code>for</code> command over <code>while</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set password to ""}
{set nb to rand(8, 16)}
{set i to 0}

{while lt(i, nb):
    {set ascii to rand(62)}

    {if lt(ascii, 10):
        {set password to cat(password, char(add(ascii, ord("0"))))}
    |elif lt(ascii, 36):
        {set password to cat(password, char(add(sub(ascii, 10), ord("A"))))}
    |else:
        {set password to cat(password, char(add(sub(ascii, 36), ord("a"))))}
    }

    {set i to add(i, 1)}
}

Your random password is: {password}.</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Your random password is: 2PIBnodftxz8jAX.</code>
					</div>
				</div>
			</div>

			<h2>Configuration options</h2>
			<div class="section">
				<h3>Using custom configuration</h3>
				<div class="section">
					<p>When creating a new Cottle document, you can pass it an
					optional <code>Cottle.ISetting</code> object which contains
					configuration parameters. If this parameter is missing then
					a default instance is used. You can use builtin
					<code>Cottle.Settings.CustomSetting</code> object to
					override any configuration parameter you want, or implement
					the interface yourself for more advanced uses:</p>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
					<code>IDocument       document;
IScope          scope;
CustomSetting   setting;

setting = new CustomSetting();

/* TODO: update setting properties */

scope = new DefaultScope();

/* TODO: assign some values to scope */

using (StreamReader template = new StreamReader(new FileStream("test.cottle", FileMode.Open), Encoding.UTF8))
{
    document = new SimpleDocument(template, setting);
}

document.Render(scope, Console.Out);</code>
					</div>
					<p>Configuration parameters can be updated where the first
					"TODO" comment is located. This code will be used for
					detailed usage of specific parameters in following
					sections.</p>
				</div>

				<h3>Raw text whitespaces cleaning</h3>
				<div class="section">
					<p>Cottle's default behavior for raw text is to render it
					without any modification. While this gives you a perfect
					character-level control of how a template is rendered, it
					may prevent you from writing clean indented code for target
					formats where white spaces are either ignored or collapsed,
					such as HTML.</p>
					<p>For that reason, you can change the way raw text is
					transformed by Cottle before it is rendered through the use
					of "cleaners". Three default cleaners are provided by
					Cottle, but you can write your own if needed. Available
					cleaners are:</p>
					<ul>
						<li>BlankCharactersCleaner: remove all leading and
						trailing blank characters from raw text blocks,</li>
						<li>FirstLastLinesCleaner: remove first and last empty
						lines from raw text blocks except for blocks that
						contain only blank characters,</li>
						<li>NullCleaner: leave raw text untouched (this is
						the default cleaner).</li>
					</ul>
					<p>Here are some simple templates and their rendered
					results using different cleaners. Unlike other examples in
					this document, exact white spaces are preserved in
					results.</p>
					<p>BlankCharactersCleaner:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{'white'} {'spaces '} around raw blocks are
going to be
{' collapsed'} .</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>setting.Cleaner = new BlankCharactersCleaner();</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>whitespaces around raw blocks are
going to be collapsed.</code>
					</div>
					<p>FirstLastLinesCleaner:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>This is a line of text with {'inline'} Cottle code.

{for s in ["normal", "exceptional", "elite"]:
    - Length of string "{s}" is {len(s)} character(s).

}</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>setting.Cleaner = new FirstLastLinesCleaner();</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>This is a line of text with inline Cottle code.
    - Length of string "normal" is 6 character(s).
    - Length of string "exceptional" is 11 character(s).
    - Length of string "elite" is 5 character(s).</code>
					</div>
					<p>NullCleaner:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Every {'white'}space from this template

{if 1:  will be}

    preserved.</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>setting.Cleaner = new NullCleaner();</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Every whitespace from this template

  will be

    preserved.</code>
					</div>
					<p>If you want to write your own cleaner, just inherit from
					the <code>Cottle.ICleaner</code> interface and implement
					required
					<code>GetRange(string text, out int start, out int length)</code>
					method. This method will be called on for each raw text
					block from input templates (the <code>text</code> argument)
					and should assign a start offset and a length which define
					the text range to be extracted and printed when document is
					rendered.</p>
				</div>

				<h3 id="block_delimiters_customization">Block delimiters customization</h3>
				<div class="section">
					<p>When using default configuration, Cottle uses {
					character to start a code block, | to continue it (before
					an <code>else</code> statement for example), and } to end
					it. These characters may not be a good choice if you want
					to write a template that makes extensive literal use of
					them, for example if you're writing a JavaScript template,
					because you would have to escape every {, } and | to avoid
					Cottle seeing them as block delimiters.</p>
					<p>To workaround this problem, you can change default block
					delimiters when creating a new document. New delimiters can
					be any string and won't be validated by Cottle, so you
					should avoid anything ambiguous otherwise the parser may
					not be able to understand your code. For example, choosing
					the ] character as a delimiter is a bad idea, as it will
					conflict with internal end-of-map delimiter.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Block delimiters are now [[block_begin]], [[block_continue]] and [[block_end]].</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>setting.BlockBegin = "[[";
setting.BlockContinue = "||";
setting.BlockEnd = "]]";

scope["block_begin"] = "double left bracket (" + setting.BlockBegin + ")";
scope["block_continue"] = "double pipe (" + setting.BlockContinue + ")";
scope["block_end"] = "double right bracket (" + setting.BlockEnd + ")";</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Block delimiters are now double left bracket ([[), double pipe (||) and double right bracket (]]).</code>
					</div>
				</div>
			</div>

			<h2>Advanced topics</h2>
			<div class="section">
				<h3>Variable contents inspection</h3>
				<div class="section">
					<p>When your template doesn't render as you would expect,
					the <code>dump</code> command can help you identify issues
					by showing value in a "printable" form. Undefined values,
					for example, won't print anything when passed through the
					<code>echo</code> command, but will appear as
					<code>&lt;void&gt;</code> with <code>dump</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump "string"}
{dump 42}
{dump unknown(3)}
{dump [856, "hello", "x": 17]}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>"string"
42
&lt;void&gt;
[0: 856, 1: "hello", "x": 17]</code>
					</div>
				</div>

				<h3>Understanding value types</h3>
				<div class="section">
					<p>Every value has a type in Cottle, even if you usually
					don't have to worry about it since casts are performed
					automatically when required. In some cases however, you may
					have to force a cast to get desired result, for example
					when accessing values from a map:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set map to ["first", "second", "third"]}
{set key to "1"}

{dump map[key]}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>&lt;void&gt;</code>
					</div>
					<p>You could have expected this template to display
					"second", but Cottle actually searches for the value
					associated to key "1" (as a string) in <code>map</code>,
					not key 1 (as a number). This can be explained by the fact
					that <code>map</code> could contain different values for
					both keys 1 and "1", and it would be perfectly valid, so no
					automatic cast can be performed for you.</p>
					<p>This can be solved by explicitely changing the type of
					<code>key</code> to a number by using the
					<a href="#function_cast">cast</a> common function.</p>
				</div>

				<h3>Functions declaration</h3>
				<div class="section">
					<p>Cottle allows you to declare functions, that are
					callable values you can use to factor code as you would do
					in a program. To declare a function and assign it to a
					variable, use the same <code>set</code> you used for
					regular values assignments with a slightly different
					syntax. Function arguments must be specified between
					parenthesis right after the variable name that should
					receive the function, and are followed by <code>to</code>
					and function body declaration.</p>
					<p>Functions can return a value that can be used in any
					expression or stored in a variable. To make a function halt
					and return a value, use the <code>return</code> command
					within its body.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set factorial(n) to:
    {if gt(n, 1):
        {return mul(n, factorial(sub(n, 1)))}
    |else:
        {return 1}
    }
}

Factorial 1 = {factorial(1)}
Factorial 3 = {factorial(3)}
Factorial 8 = {factorial(8)}

{set hanoi_rec(n, from, by, to) to:
    {set n to sub(n, 1)}

    {if gt(n, 0): {hanoi_rec(n, from, to, by)}}
Move one disk from {from} to {to}
    {if gt(n, 0): {hanoi_rec(n, by, from, to)}}
}

{set hanoi(n) to:
    {hanoi_rec(n, "A", "B", "C")}
}

{hanoi(3)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Factorial 1 = 1
Factorial 3 = 6
Factorial 8 = 40320

Move one disk from A to C
Move one disk from A to B
Move one disk from C to B
Move one disk from A to C
Move one disk from B to A
Move one disk from B to C
Move one disk from A to C</code>
					</div>
					<p>You can see in this example that returning a value and
					printing text are two very different things. Raw text
					within function body is printed each time the function is
					called, or more precisely each time its enclosing block is
					executed (that means it won't print if contained in an
					<code>if</code> command that fails to pass, for example).
					The value returned by the function won't be printed unless
					you explicitly require it by using the <code>echo</code>
					command (e.g. something like <code>{factorial(8)}</code>).
					If a function doesn't use any <code>return</code> command,
					the value it returns is empty, that's why the call to
					<code>{hanoi(3)}</code> in the sample above does not print
					anything more than the raw text blocks it contains.</p>
				</div>

				<h3>Variables scopes</h3>
				<div class="section">
					<p>When writing complex templates using nested or recursive
					functions, you may have to take care of variable scopes to
					avoid potential issues. A scope is the local evaluation
					context of any function or command that have a body. When
					assigning a value to a variable as described in paragraph
					"<a href="#variables_assignment">Variables assignment</a>",
					all variables belong to the same top-level scope. Consider
					this template:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set depth(item) to:
    {set res to 0}

    {for child in item:
        {set res_child to add(depth(child), 1)}
        {set res to max(res, res_child)}
    }

    {return res}
}

{depth([["1.1", "1.2", ["1.3.1", "1.3.2"]], "2", "3", ["4.1", "4.2"]])}</code>
					</div>
					<p>The <code>depth</code> function is expected to return
					the level of the deepest element in a value that contains
					nested maps. Of course it could be written in a much more
					efficient way without using non necessary temporary
					variables, but it would hide the problem we want to
					illustrate. Anyway, we want this code to return a valid
					result, and if you try to execute it you'll notice that it
					returns <code>2</code> where <code>3</code> would have been
					expected.</p>
					<p>Here is the explanation: when using the <code>set</code>
					method to assign a value to variable <code>res</code>, it
					always uses the same <code>res</code> instance.
					The <code>depth</code> function recursively calls itself
					but overwrite the unique <code>res</code> variable each
					time it tries to store a value in it, and therefore fails
					to store the actual deepest level as it should.</p>
					<p>To solve this issue, the <code>res</code> variable needs
					to be local to function <code>depth</code>, that means each
					call to <code>depth</code> must use its own instance of the
					<code>res</code> variable. This can be achieved by using
					the <code>declare</code> command that creates a variable in
					current scope. Our previous example can then be fixed by
					declaring a new <code>res</code> variable inside body of
					function <code>depth</code>, so that every subsequent
					reference to <code>res</code> resolves to our local
					instance:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set depth(item) to:
    <strong>{declare res}</strong>
    {set res to 0}

    {for child in item:
        {set res_child to add(depth(child), 1)}
        {set res to max(res, res_child)}
    }

    {return res}
}

{depth([["1.1", "1.2", ["1.3.1", "1.3.2"]], "2", "3", ["4.1", "4.2"]])}</code>
					</div>
					<p>You could even optimize the first <code>set</code>
					command away by assigning a value to <code>res</code>
					during declaration ; the <code>declare</code> command
					allows you to assign functions or values to variables by
					using the same kind of syntax than the <code>set</code>
					command, the only difference being than "to" should be
					replaced by "as":</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{declare res as 0}</code>
					</div>
					<p>The same command can also be used to declare
					functions:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{declare depth(item) as:
    ...
}</code>
					</div>
					<p>Note that the <code>set</code> command can also be used
					without a value. Declaring or setting a variable without a
					value is equivalent to asigning it a void value.</p>
				</div>

				<h3>Custom .NET methods</h3>
				<div class="section">
					<p>If you need new features or improved performance, you
					can assign your own .NET methods to template variables.
					That's actually what Cottle does when you use a
					<code>DefaultScope</code> object in your code: a set of
					internal .NET methods is assigned to predefined variables
					within the scope, and you can have a look at source code to
					see how these methods work.</p>
					<p>To assign a method to a scope, just wrap it within a
					<code>CallbackFunction</code> object contained by a
					<code>FunctionValue</code> object, then add it to the
					<code>Value</code> property of your <code>Document</code>
					instance, as you would do for any regular variable:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Testing custom "repeat" function:

{repeat("a", 15)}
{repeat("hello! ", 3)}
{repeat("-", 10)}</code>
					</div>
					<div class="code">
					<blockquote><span>C# code:</span></blockquote>
<code>scope["repeat"] = new FunctionValue(new CallbackFunction(delegate(IList&lt;Value&gt; values, IScope scope, TextWriter output)
{
    StringBuilder builder = new StringBuilder();
    int           i;

    for (i = 0; i &lt; values[1].AsNumber; ++i)
        builder.Append(values[0].AsString);

    return builder.ToString();
}, 2));</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Testing custom "repeat" function:

aaaaaaaaaaaaaaa
hello! hello! hello! 
----------</code>
					</div>
					<p>Your custom .NET method must take three arguments:</p>
					<ul>
						<li>The list of arguments passed to the function
						(values),</li>
						<li>Current variables scope (scope),</li>
						<li>Document text writer object (output).</li>
					</ul>
					<p>Arguments are instances of the <code>Value</code> class,
					which can hold data of any type known by Cottle. You can
					access their <code>AsBoolean</code>,
					<code>AsFunction</code>, <code>AsNumber</code> and
					<code>AsString</code> properties to get data of desired
					type (automatic type conversion will be performed if
					needed). You can also use the <code>Type</code> property to
					know which data type a <code>Value</code> instance is
					actually holding. The <code>Fields</code> property contains
					all key/value pairs.</p>
					<p>In most cases you won't use scope and output text
					writer, but may need them if you want to run a function
					evaluation within your code. The text writer instance can
					however be used if you want your function to print
					something.</p>
					<p>The <code>CallbackFunction</code> objects also takes 2
					more optional arguments, used to indicate how many
					arguments are expected for your function. You can either
					ignore those arguments (and check yourself how many
					values your function received), specify an exact number of
					expected arguments, or specify min/max boundaries (-1 as a
					max boundary means "unlimited"). When specifying expected
					arguments count, Cottle will perform this check for you
					each time your function is invoked and ignore the call on
					error.</p>
					<p>Your custom function is expected to return a
					<code>Value</code> object. Remember that implicit
					constructors are available, so returning a compatible .NET
					native type is valid too.</p>
				</div>

				<h3>Lazy evaluation</h3>
				<div class="section">
					<p>In some cases, you may want to inject to your template
					big and/or complex values that may or may not be needed at
					rendering, depending on other parameters. In such
					configurations, it may be better to avoid injecting the
					entire value in your scope if there is chances it won't be
					used, and use lazy evaluation instead.</p>
					<p>Lazy evaluation allows you to inject a value with a
					"resolver" callback which will be called only the first
					time value is accessed, or not called at all if value is
					not used for rendering. Lazy values are just another
					specialized version of the <code>Value</code> object and
					are built from any resolver callback that returns a
					<code>Value</code> instance:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{if is_admin:
    Administration log:
    {log}
}</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope = new DefaultScope();
scope["is_admin"] = user.IsAdmin();
scope["log"] = () => log.BuildComplexAdministrationLogValue(); // implicit conversion to LazyValue

document.Render(scope, Console.Out);</code>
					</div>
					<p>In this example, method
					<code>log.BuildComplexAdministrationLogValue</code> won't
					be called unless <code>is_admin</code> value is true.</p>
				</div>

				<h3>Inspect objects through reflection</h3>
				<div class="section">
					<p>Instead of converting complex object hierarchies to
					Cottle values, you can have the library do it for you by
					using .NET reflection. Keep in mind that reflection is
					significantly slower than creating Cottle values manually,
					but as it's a lazy mechanism it may be a good choice if you
					have complex objects and don't know in advance which fields
					might be used in your templates.</p>
					<p>To use reflection, create a new ReflectionValue from any
					.NET object instance, and push it to your scope. Its fields
					and properties will be accessible like if it were a Cottle
					map:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>Your image has a size of {image.Width} x {image.Height} pixels.

{for key, value in image:
  {key} = {value}
}</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["image"] = new ReflectionValue(new Bitmap(50, 50));</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Your image has a size of 50 x 50 pixels.

nativeImage =
Tag =
PhysicalDimension =
Size =
Width = 50
Height = 50
HorizontalResolution = 96
VerticalResolution = 96
Flags = 2
RawFormat =
PixelFormat =
Palette =
FrameDimensionsList =
PropertyIdList =
PropertyItems =</code>
					</div>
					<p>By default, a <code>ReflectionValue</code> will read all
					instance members, both public and private. If you want to
					change this behavior, specify your BindingFlags as a second
					parameter to <code>ReflectionValue</code> constructor.</p>
				</div>
			</div>

			<h2 id="common_functions">Common functions</h2>
			<div class="section">
				<h3>Absolute value: abs(numeric)</h3>
				<div class="section">
					<p>Return the absolute value of given numeric value.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{abs(-3)}
{abs(5)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>3
5</code>
					</div>
				</div>

				<h3>Compute sum of two values: add(a, b)</h3>
				<div class="section">
					<p>Return the sum of two numeric values.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{add(3, 7)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>10</code>
					</div>
				</div>

				<h3>Logical AND: and(a, b, ...)</h3>
				<div class="section">
					<p>Perform logical "and" between given boolean values, i.e.
					return "true" if every argument is true.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{and(lt(2, 3), gt(5, 1))}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true</code>
					</div>
				</div>

				<h3>Use map values as another function's arguments:
				call(func, map)</h3>
				<div class="section">
					<p>Call function <code>func</code> with values from given
					map as arguments (keys are not used).</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{call(cat, ["Hello", ", ", "World", "!"])}
{call(max, [3, 8, 2, 7])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Hello, World!
8</code>
					</div>
				</div>

				<h3 id="function_cast">Convert value to a scalar type:
				cast(value, type)</h3>
				<div class="section">
					<p>Get value converted to requested scalar type. Type must
					be a string value specifying desired type:</p>
					<ul>
						<li>b: convert to boolean value</li>
						<li>n: convert to numeric value</li>
						<li>s: convert to string value</li>
					</ul>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump eq(2, cast("2", "n"))}
{dump ["value for key 0"][cast("0", "n")]}
{dump cast("some string", "b")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>&lt;true&gt;
"value for key 0"
&lt;true&gt;</code>
					</div>
				</div>

				<h3 id="function_cat">Concatenate values: cat(a, b, ...)</h3>
				<div class="section">
					<p>Concatenate all input values into a single one. This
					function works on both strings and maps.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{cat("Hello, ", "World!")}
{for v in cat([1, 2], [3]): {v}}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>Hello, World!
1 2 3</code>
					</div>
				</div>

				<h3>Returns the smallest integer greater than or equal to the
				specified number: ceil(x)</h3>
				<div class="section">
					<p>Returns the smallest integer greater than or equal to
					decimal value <code>x</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{ceil(2.7)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>3</code>
					</div>
				</div>

				<h3>Get character from unicode value: char(int)</h3>
				<div class="section">
					<p>Get a 1-character string from its unicode numeric
					value. See
					<a href="http://en.wikipedia.org/wiki/Unicode">Unicode on
					Wikipedia</a> for details.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{char(97)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>a</code>
					</div>
				</div>

				<h3>Compare two values: cmp(a, b)</h3>
				<div class="section">
					<p>Compare <code>a</code> against <code>b</code>, and
					return -1 if <code>a</code> is lower than <code>b</code>,
					0 if they're equal, or 1 else. When used on numeric
					values, the <code>cmp</code> function uses numerical order.
					When used on strings, it uses alphabetical order. When
					used on maps, it first compare their lengths then compare
					their values if lengths are equal. Two values of different
					types are always different.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{cmp("abc", "bcd")}
{cmp(9, 6)}
{cmp([2, 4], [2, 4])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>-1
1
0</code>
					</div>
				</div>

				<h3>Compute cosine of an angle: cos(x)</h3>
				<div class="section">
					<p>Get the cosine of angle <code>x</code> in radians.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{cos(-1.57)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>0.000796326710733263</code>
					</div>
				</div>

				<h3>Cross-join pairs in a map: cross(map1, map2, ...)</h3>
				<div class="section">
					<p>Return a map containing all pairs from
					<code>map1</code> having a key that also exists in
					<code>map2</code> and all following maps. Output pair
					values will always be taken from <code>map1</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump cross([1: "a", 2: "b", 3: "c"], [1: "x", 3: "y"])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>[1: "a", 3: "c"]</code>
					</div>
				</div>

				<h3>Get input value or default value: default(test[,
				fallback])</h3>
				<div class="section">
					<p>Return <code>test</code> if it
					<a href="#conditional_statements">evaluates to true</a>, or
					<code>fallback</code> otherwise (or a void value if
					<code>fallback</code> is missing).</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set x to 3}
{dump default(x, "invisible")}
{dump default(y, "visible")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>3
"visible"</code>
					</div>
				</div>

				<h3>Compute divide result of two values: div(a, b)</h3>
				<div class="section">
					<p>Return the numeric value of <code>a</code> divided by
					the numeric value of <code>b</code>. Result of a division
					by zero is a void value.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{div(5, 2)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>2.5</code>
					</div>
				</div>

				<h3>Test if values are equal: eq(a, b, ...)</h3>
				<div class="section">
					<p>Return true if all arguments are equal, or false
					otherwise. See <a href="#function_cmp">cmp</a> common
					function for more information about comparisons.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{eq(7, 7)}
{eq(1, 4)}
{eq("test", "test")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true
false
true</code>
					</div>
				</div>

				<h3 id="function_except">Remove pairs from a map:
				except(map1, map2, ...)</h3>
				<div class="section">
					<p>Return a map containing all pairs from <code>map1</code>
					having a key that does not exist in <code>map2</code> and
					any of following maps. This function can also be used to
					remove a single pair from a map (if you are sure that it's
					key is not used by any other pair, otherwise all pairs
					using that key would be removed also).</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump except([1: "a", 2: "b", 3: "c"], [2: "x", 4: "y"])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>[1: "a", 3: "c"]</code>
					</div>
				</div>

				<h3>Filter values from a map: filter(map, predicate[, a,
				b, ...])</h3>
				<div class="section">
					<p>Return a map containing all pairs having a value that
					satisfies given predicate. Function <code>predicate</code>
					is invoked for each value from <code>map</code> with this
					value as its first argument, and pair is added to output
					map if predicate result
					<a href="#conditional_statements">evaluates to true</a>.</p>
					<p>Optional arguments can be specified when calling
					<code>filter</code> and will be passed to each invocation
					of <code>predicate</code> as second, third, forth argument
					and so on.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{declare multiple_of(x, y) as: {return eq(mod(x, y), 0)}}
{for v in filter([1, 6, 7, 4, 9, 5, 0], multiple_of, 3): {v}}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>6 9 0</code>
					</div>
				</div>

				<h3>Find index of element in a value: find(value, token[,
				start])</h3>
				<div class="section">
					<p>Find the 0-based index of given token in a map, or
					sub-string in a string. Search starts at index 0 unless
					<code>start</code> argument is specified.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{find([89, 3, 572, 35, 7], 35)}
{find("hello, world!", "o", 5)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>3
8</code>
					</div>
				</div>

				<h3>Swap keys and values in a map: flip(map)</h3>
				<div class="section">
					<p>Return a map were pairs are created by swapping each
					key and value pair from input map. Using resulting map
					with the <code>for</code> command will still iterate
					through each pair even if there was duplicates, but only
					the last occurrence of each duplicate can be accessed
					using map subscript operator ([]).</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump flip([1: "hello,", 2: "world!"])}
{dump flip(["a": 0, "b": 0])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>["hello,": 1, "world!": 2]
[0: "a", 0: "b"]</code>
					</div>
				</div>

				<h3>Returns the largest integer less than or equal to the
				specified number: floor(x)</h3>
				<div class="section">
					<p>Returns the largest integer less than or equal to
					decimal value <code>x</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{floor(2.7)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>2</code>
					</div>
				</div>

				<h3>Apply .NET formatting on value: format(value, format[,
				culture])</h3>
				<div class="section">
					<p>Convert any <code>value</code> to a string using given
					formatting from <code>format</code> string expression.
					Format should use syntax "expr" or "t:expr" where "t"
					indicates the type of the formatter to use, and "expr" is
					the .NET format specifier. Available formatter types
					are:</p>
					<ul>
						<li>a: automatic (default, used if "t" is omitted)</li>
						<li>b: System.Boolean</li>
						<li>d or du: System.DateTime (UTC)</li>
						<li>dl: System.DateTime (local)</li>
						<li>i: System.Int64</li>
						<li>n: System.Decimal</li>
						<li>s: System.String</li>
					</ul>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{format(1339936496, "d:yyyy-MM-dd HH:mm:ss")}
{format(0.165, "n:p2", "fr-FR")}
{format(1, "b:n2")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>2012-06-17 12:34:56
16,50 %
True</code>
					</div>
					<p>Formatters use current culture, unless a culture name is
					specified in the <code>culture</code> argument. See
					<a href="http://msdn.microsoft.com/fr-fr/goglobal/bb896001.aspx">National Language Support API on MSDN</a>
					for a list of valid culture names.</p>
				</div>

				<h3>Test if a value is greater or equal to another: ge(a,
				b)</h3>
				<div class="section">
					<p>Return true if the numeric value of <code>a</code> is
					greater than or equal to the numeric value of
					<code>b</code>, false otherwise.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{ge(7, 3)}
{ge(2, 2)}
{ge("abc", "abx")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true
true
false</code>
					</div>
				</div>

				<h3>Test if a value is greater than another: gt(a, b)</h3>
				<div class="section">
					<p>Return true if the numeric value of <code>a</code> is
					greater than the numeric value of  <code>b</code>, false
					otherwise.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{gt(7, 3)}
{gt(2, 2)}
{ge("abc", "abx")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true
false
false</code>
					</div>
				</div>

				<h3>Check if a map value contains given key: has(map,
				key)</h3>
				<div class="section">
					<p>Return true if given map has a value associated to
					given key, or false otherwise.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{has(["name": "Paul", "age": 37, "sex": "M"], "age")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true</code>
					</div>
				</div>

				<h3>Include and render template file: include(path[, map[,
				map, ...]])</h3>
				<div class="section">
					<p>Parse document from a template file and render it with
					variables extracted from given maps. Keys from input
					maps will be used as variable names associated to their
					respective values. For this example, we'll assume that a
					file named "article.cottle" is available in current
					directory and contains this template code:</p>
					<div class="code">
						<blockquote><span>Template
						"article.cottle":</span></blockquote>
<code>&lt;div class="box"&gt;
    &lt;div class="title"&gt;{a.title}&lt;/div&gt;
    &lt;div class="text"&gt;{a.text}&lt;/div&gt;
&lt;/div&gt;</code>
					</div>
					<p>Now, we want to include and render this template file in
					our global rendering:</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{for article in articles:
    {include("article.cottle", ["a": article])}
}</code>
					</div>
					<div class="code">
						<blockquote><span>C# code:</span></blockquote>
<code>scope["articles"] = new Value[]
{
    new Dictionary&lt;Value, Value&gt;
    {
        {"title", "First article"},
        {"text", "Lorem ipsum dolor sit amet, consectetur adipiscing elit."}
    },
    new Dictionary&lt;Value, Value&gt;
    {
        {"title", "Second article"},
        {"text", "Cras vitae erat dui, commodo gravida purus."}
    }
};</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>&lt;div class="box"&gt;
    &lt;div class="title"&gt;First article&lt;/div&gt;
    &lt;div class="text"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/div&gt;
&lt;/div&gt;
&lt;div class="box"&gt;
    &lt;div class="title"&gt;Second article&lt;/div&gt;
    &lt;div class="text"&gt;Cras vitae erat dui, commodo gravida purus.&lt;/div&gt;
&lt;/div&gt;</code>
					</div>
					<p>By using <code>return</code> keyword in your included
					template, you can pass a value to the calling template (it
					will be available as the result of the call to function
					<code>include</code>).</p>
					<p>For performance reasons, included templates are stored
					in an internal cache which keeps parsed versions of the
					last 256 included documents. If you want to change cache
					size, use the <code>CommonFunctions.IncludeCacheSize</code>
					property. You can also disable the cache by setting the
					<code>CommonFunctions.IncludeCacheEnabled</code> to
					<code>false</code> ; be sure to set it back to
					<code>true</code> before deploying your code to a
					production environment.</p>
				</div>

				<h3>Join values from a map: join(map[, string])</h3>
				<div class="section">
					<p>Concatenate all values from given map pairs, using
					given string as a separator (or empty string if no
					separator is provided).</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{join(["2011", "01", "01"], "/")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>2011/01/01</code>
					</div>
				</div>

				<h3>Convert string to lowercase: lcase(string)</h3>
				<div class="section">
					<p>Return a lowercase conversion of given string value.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{lcase("Mixed Case String"}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>mixed case string</code>
					</div>
				</div>

				<h3>Get length of a value: len(a)</h3>
				<div class="section">
					<p>Return the length or given value, that is number pairs
					if value was a map, or number of characters if value
					was a string.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{len("Hello!")}
{len([17, 22, 391, 44])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>6
4</code>
					</div>
				</div>

				<h3>Test if a value is lower or equal to another: le(a, b)</h3>
				<div class="section">
					<p>Return true if the numeric value of <code>a</code> is
					lower than or equal to the numeric value of <code>b</code>,
					false otherwise.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{le(3, 7)}
{le(2, 2)}
{le("abc", "abx")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true
true
true</code>
					</div>
				</div>

				<h3>Test if a value is lower than another: lt(a, b)</h3>
				<div class="section">
					<p>Return true if the numeric value of <code>a</code> is
					lower than the numeric value of <code>b</code>, false
					otherwise.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{lt(3, 7)}
{lt(2, 2)}
{lt("abc", "abx")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true
false
true</code>
					</div>
				</div>

				<h3>Applying function to each value in a map: map(map,
				modifier[, a, b, ...])</h3>
				<div class="section">
					<p>Return a map where values are built by applying given
					modifier to original map values, while preserving keys.
					Function <code>modifier</code> is invoked for each value in
					<code>map</code> with this value as its first
					argument.</p>
					<p>Optional arguments can be specified when calling
					<code>map</code> and will be passed to each invocation of
					<code>modifier</code> as second, third, forth argument and
					so on.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{declare square(x) as: {return mul(x, x)}}
{for v in map([1, 2, 3, 4], square): {v}}

{dump map(["a": 1, "b": 7, "c": 4, "d": 5, "e": 3, "f": 2, "g": 6], lt, 4)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>1 4 9 16
["a": 1, "b": 0, "c": 0, "d": 0, "e": 1, "f": 1, "g": 0]</code>
					</div>
				</div>

				<h3>Match string against a regular expression: match(string,
				pattern)</h3>
				<div class="section">
					<p>Match <code>string</code> against given regular
					expression pattern. If match is successful, a map
					containing each captured group is returned, otherwise
					result is a void value. See
					<a href="http://msdn.microsoft.com/en-us/library/hs600312(v=vs.71).aspx">.NET
					Framework Regular Expressions</a> for more information.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump match("abc123", "^[a-z]+([0-9]+)$")}
{dump match("xyz", "^[a-z]+([0-9]+)$")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>[0: "abc123", 1: "123"]
&lt;void&gt;</code>
					</div>
				</div>

				<h3>Get the maximum between 2 or more values: max(a[, b[,
				c, ...]])</h3>
				<div class="section">
					<p>Return the highest numeric value among given ones.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{max(7, 5)}
{max(6, 8, 5, 7, 1, 2)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>7
8</code>
					</div>
				</div>

				<h3>Get the minimum between 2 or more values: min(a[, b[,
				c, ...]])</h3>
				<div class="section">
					<p>Return the lowest numeric value among given ones.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{min(9, 3)}
{min(6, 8, 5, 7, 1, 2)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>3
1</code>
					</div>
				</div>

				<h3>Compute reminder of two values: mod(a, b)</h3>
				<div class="section">
					<p>Return the value of the first numeric argument modulo
					the second one.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{mod(7, 3)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>1</code>
					</div>
				</div>

				<h3>Compute product of two values: mul(a, b)</h3>
				<div class="section">
					<p>Return the numeric value of <code>a</code> times
					<code>b</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{mul(3, 4)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>12</code>
					</div>
				</div>

				<h3>Logical NOT: not(a)</h3>
				<div class="section">
					<p>Perform logical "not" on given boolean value, i.e return
					true if value was false or false if it was true.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{not(eq(1, 2))}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true</code>
					</div>
				</div>

				<h3>Logical OR: or(a, b, ...)</h3>
				<div class="section">
					<p>Perform logical "or" between given boolean values, i.e.
					return "true" if at least one argument is true.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{or(eq(2, 3), gt(5, 1))}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true</code>
					</div>
				</div>

				<h3>Get unicode value from character: ord(char)</h3>
				<div class="section">
					<p>Get the numeric unicode value of the first character
					of given string. See
					<a href="http://en.wikipedia.org/wiki/Unicode">Unicode on
					Wikipedia</a> for details.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{ord("a")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>97</code>
					</div>
				</div>

				<h3>Raise a number to a power: pow(x, y)</h3>
				<div class="section">
					<p>Get specified number <code>x</code> raised to the power
					<code>y</code>.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{pow(2, 10)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>1024</code>
					</div>
				</div>

				<h3>Generate pseudo-random value: rand([a[, b]])</h3>
				<div class="section">
					<p>Get a pseudo-random numeric value between 0 and
					2.147.483.647 inclusive. If numeric <code>a</code> value
					is specified, return a pseudo-random numeric value
					between 0 and <code>a</code> exclusive. If both numeric
					values <code>a</code> and <code>b</code> are specified,
					return a pseudo-random numeric value between
					<code>a</code> inclusive and <code>b</code> exclusive.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{rand()}
{rand(1, 7)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>542180393
5</code>
					</div>
				</div>

				<h3>Generate arithmetic progression: range([start, ]stop[,
				step])</h3>
				<div class="section">
					<p>Generate a map where value of the <em>i</em>-th pair
					is <em>start + step * i</em> and last value is lower than
					<code>stop</code>. Default base index is 0 if the
					<code>start</code> argument is omitted, and default value
					for <code>step</code> is 1.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{for v in range(5): {v}}
{for v in range(2, 20, 3): {v}}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>0 1 2 3 4
2 5 8 11 14 17</code>
					</div>
				</div>

				<h3>Rounds a value to the nearest integer or specified number
				of decimal places: round(x[, y])</h3>
				<div class="section">
					<p>Rounds a decimal value to a specified number of
					fractional digits <code>y</code>, or to the nearest
					integral value if <code>y</code> is not specified.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{round(1.57)}
{round(1.57, 1)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>2
1.6</code>
					</div>
				</div>

				<h3>Compute sine of an angle: sin(x)</h3>
				<div class="section">
					<p>Get the sine of angle <code>x</code> in radians.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{sin(1.57)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>0.999999682931835</code>
					</div>
				</div>

				<h3 id="function_slice">Extract part of value: slice(value,
				index[, count])</h3>
				<div class="section">
					<p>Extact slice from a map, or sub-string from a
					string. <code>count</code> pairs or characters are
					extracted from given 0-based numeric <code>index</code>. If
					no <code>count</code> argument is specified, all elements
					starting from given <code>index</code> are extracted.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{for v in slice([68, 657, 54, 3, 12, 9], 3, 2): {v}}
{slice("abchello", 4)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>3 12
hello</code>
					</div>
				</div>

				<h3>Get sorted map: sort(map[, callback])</h3>
				<div class="section">
					<p>Return a sorted copy of given map. First argument is
					the input map, and will be sorted using natural order
					(numerical or alphabetical, depending on value types) by
					default. You can specify a second argument as
					comparison delegate, that should accept two arguments and
					return -1 if the first should be placed "before" the
					second, 0 if they are equal, or 1 otherwise.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set shuffled to ["in", "order", "elements" "natural"]}

{for item in sort(shuffled):
    {item}
}

{declare by_length(a, b) as:
    {return cmp(len(b), len(a))}
}

{set shuffled to ["by their", "are sorted", "length", "these strings"]}

{for item in sort(shuffled, by_length):
    {item}
}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>elements
in
natural
order

these strings
are sorted
by their
length</code>
					</div>
				</div>

				<h3>Split string into map: split(input, separator)</h3>
				<div class="section">
					<p>Split string <code>input</code> according to given
					string separator <code>separator</code>. Result is an
					map where pair values contain split sub-strings.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump split("2011/01/01", "/")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>[0: "2011", 1: "01", 2: "01"]</code>
					</div>
				</div>

				<h3>Compute difference between two values: sub(a, b)</h3>
				<div class="section">
					<p>Return the numeric value of a minus b.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{sub(3, 5)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>-2</code>
					</div>
				</div>

				<h3>Convert string to uppercase: ucase(string)</h3>
				<div class="section">
					<p>Return an uppercase conversion of given string
					value.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{ucase("Mixed Case String"}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>MIXED CASE STRING</code>
					</div>
				</div>

				<h3 id="function_union">Get union of two maps: union(map1,
				map2, ...)</h3>
				<div class="section">
					<p>Return a map containing all pairs from input maps,
					but without duplicating any key. If a key exists more than
					once in all input maps, the last one will overwrite any
					previous pair using it.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{dump union([1: "a", 2: "b"], [2: "x", 3: "c"], [4: "d"])}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>[1: "a", 2: "x", 3: "c", 4: "d"]</code>
					</div>
				</div>

				<h3>Get value depending on a conditional test: when(test[,
				true_part[, false_part]])</h3>
				<div class="section">
					<p>Return <code>true_part</code> if <code>test</code>
					<a href="#conditional_statements">evaluates to true</a>, or
					<code>false_part</code> otherwise
					(or a void value if <code>false_part</code> is
					missing).</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set x to 3}
{set y to 0}
{dump when(x, "x is true", "x is false")}
{dump when(y, "y is true", "y is false")}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>"x is true"
"y is false"</code>
					</div>
				</div>

				<h3>Logical exclusive OR: xor(a, b, ...)</h3>
				<div class="section">
					<p>Perform logical "xor" between given boolean values, i.e.
					return "true" if exactly one argument is true and all the
					others are false.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{xor(lt(2, 3), eq(1, 2))}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>true</code>
					</div>
				</div>

				<h3>Combine two maps values into pairs: zip(a, b)</h3>
				<div class="section">
					<p>Combine given maps to create a new one. The n-th pair
					in result map will use the n-th value from first map as
					its key and the n-th value of second map as its value. If
					the two maps don't have the same length, exceeding
					elements from the longest map are ignored.</p>
					<div class="code">
						<blockquote><span>Template:</span></blockquote>
<code>{set a to ["key1", "key2", "key3"]}
{set b to ["value1", "value2", "value3"]}
{dump zip(a, b)}</code>
					</div>
					<div class="code">
						<blockquote><span>Result:</span></blockquote>
<code>["key1": "value1", "key2": "value2", "key3": "value3"]</code>
					</div>
				</div>
			</div>

			<h2>Reference</h2>
			<div class="section">
				<h3>Change log</h3>
				<div class="section">
					<p>Cottle version numbers use format A.B.C.D where:</p>
					<ul>
						<li>A changes when code base is entirely rewritten from
						scratch, meaning that no compatibility exists with API
						from the previous version (B, C and D are reset to 0)
						;</li>
						<li>B changes when backwards incompatible changes are
						introduced to the API (C and D are reset to 0 );</li>
						<li>C changes when significant new features are added
						to the API without any loss of compatibility (D is
						reset to 0) ;</li>
						<li>D changes when a bugfix, patch or any other minor
						change is released.</li>
					</ul>
					<p>Here is a summary of important and/or potentially
					backward-incompatible changes made to the library:</p>
					<ul>
						<li>1.0.0.9 =&gt; 1.0.1.0:
							<ul>
								<li>Local variables must now be declared with
								the new <code>declare</code> command.</li>
								<li>Changed meaning of the <code>set</code>
								command (using it with "as" is
								deprecated).</li>
								<li>Command <code>define</code> is now
								deprecated (both <code>set</code> and
								<code>declare</code> can be used to assign
								functions).</li>
							</ul>
						</li>
						<li>1.0.1.0 =&gt; 1.1.0.0:
							<ul>
								<li><code>LexerConfig</code> must be replaced
								by <code>CustomSetting</code> object to change
								configuration.</li>
								<li><code>FieldMap</code> has been replaced by
								multiple implementations of the new
								<code>IMap</code> interface.</li>
								<li>Two values with different types are always
								different, even if casts could have made them
								equal (i.e. removed automatic casts when
								comparing values).</li>
								<li>Common functions <code>cross</code> and
								<code>except</code> now preserve duplicated
								keys.</li>
							</ul>
						</li>
					</ul>
				</div>

				<h3>Greetings</h3>
				<div class="section">
					<ul>
						<li>Huge thanks to
						<a href="http://www.yaronet.com/blogs/blog.php?id=456">Zerosquare</a>
						for the lovely project icon!</li>
					</ul>
				</div>

				<h3>Contact</h3>
				<div class="section">
					<p>Contact me by e-mail: cottle [at] mirari [dot] fr</p>
					<p><a href="http://remi.caput.fr/">RCa</a>, 2012</p>
				</div>
			</div>
		</div>
		<div class="toc" id="toc-data">
			<div>
				<span class="handle">Table of contents</span>
			</div>
		</div>

		<script type="text/javascript">
<!--
(function (target, source, depth)
{
	var	anchor;
	var child;
	var current;
	var	next;
	var	node;
	var parent;
	var stack;
	var unique;

	stack =
	[{
		elements	: source.childNodes,
		index		: 0,
		num			: 0
	}];

	unique = 0;

	while (stack.length > 0)
	{
		current = stack[stack.length - 1];

		if (current.index < current.elements.length)
		{
			node = current.elements[current.index++];

			if (node.tagName !== undefined && node.tagName.length == 2 && node.tagName[0] == 'H')
			{
				++current.num;

				next = parseInt (node.tagName.substr (1));

				for (; next < depth; --depth)
					target = target.parentNode.parentNode;

				node.innerHTML = ' ' + node.innerHTML;

				for (var i = stack.length; i-- > 0; )
					node.innerHTML = stack[i].num + '.' + node.innerHTML;

				if (!node.id)
					node.id = 'toc' + unique++;

				anchor = document.createElement ('a');
				anchor.innerHTML = node.innerHTML;
				anchor.href = '#' + node.id;

				child = document.createElement ('li');
				child.appendChild (anchor);

				for (; next > depth; ++depth)
				{
					parent = undefined;

					for (var j = 0; j < target.childNodes.length; ++j)
					{
						if (target.childNodes[j].tagName !== undefined)
							parent = target.childNodes[j];
					}

					target = document.createElement ('ul');
					target.appendChild (child);

					if (parent !== undefined)
						parent.appendChild (target);
				}

				target.appendChild (child);
			}

			if (node.childNodes !== undefined)
			{
				stack.push
				({
					elements	: node.childNodes,
					index		: 0,
					num			: 0
				});
			}
		}
		else
			stack.pop ();
	}
}) (document.getElementById ('toc-data'), document.getElementById ('toc-from'), 1);
-->
		</script>
	</body>
</html>
